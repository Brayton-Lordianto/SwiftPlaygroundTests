{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red155\green35\blue147;\red255\green255\blue255;\red0\green0\blue0;
\red11\green79\blue121;\red15\green104\blue160;\red28\green0\blue207;\red28\green70\blue74;\red50\green109\blue116;
\red93\green108\blue121;\red108\green54\blue169;\red196\green26\blue22;\red57\green0\blue160;\red74\green85\blue96;
}
{\*\expandedcolortbl;;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0\c85000;
\csgenericrgb\c4314\c30980\c47451;\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c10981\c27276\c28869;\csgenericrgb\c19418\c42935\c45455;
\csgenericrgb\c36526\c42188\c47515;\csgenericrgb\c42190\c21278\c66379;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c29020\c33333\c37647;
}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Linked List\
\
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f1\b\fs22 \cf2 \cb3 struct
\f2\b0 \cf4  \cf5 Node\cf4  \{\
    \cf6 Node\cf4 (
\f1\b \cf2 int
\f2\b0 \cf4  data = \cf7 0\cf4 , \cf8 Node\cf4 * next = 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) : \cf9 data\cf4 (data), \cf9 next\cf4 (next) \{\}\
    
\f1\b \cf2 int
\f2\b0 \cf4  data;\
    \cf8 Node\cf4 * next;\
\};\
\
\cf10 /*\cf4 \
\cf10   display\cf4 \
\cf10   length/size\cf4 \
\cf10   add, remove at front / back / etc.\cf4 \
\cf10   clear\cf4 \
\cf10   duplicate\cf4 \
\cf10  */\cf4 \
\
\cf8 Node\cf4 * \cf6 listDuplicate\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * headPtr) \{\
    \cf10 // edge case\cf4 \
    
\f1\b \cf2 if
\f2\b0 \cf4  (headPtr == 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) 
\f1\b \cf2 return
\f2\b0 \cf4  
\f1\b \cf2 nullptr
\f2\b0 \cf4 ;\
    \
    \cf10 // initialization code\cf4 \
    \cf8 Node\cf4 * result = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (headPtr->\cf9 data\cf4 );\
    
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * p = headPtr->\cf9 next\cf4 ;\
    \cf8 Node\cf4 * last = result;\
\
    
\f1\b \cf2 while
\f2\b0 \cf4  (p != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    last->\cf9 next\cf4  = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (p->\cf9 data\cf4 );\
    last = last->\cf9 next\cf4 ;\
    p = p->\cf9 next\cf4 ;\
    \}\
\
    
\f1\b \cf2 return
\f2\b0 \cf4  result;\
\}\
\
\

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listAddTail\cf4 (\cf8 Node\cf4 * headPtr, 
\f1\b \cf2 int
\f2\b0 \cf4  data) \{\
    
\f1\b \cf2 if
\f2\b0 \cf4  (headPtr == 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    headPtr = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (data);\
    \} 
\f1\b \cf2 else
\f2\b0 \cf4  \{\
    \cf10 // find last node\cf4 \
    \cf8 Node\cf4 * last = headPtr;\
    
\f1\b \cf2 while
\f2\b0 \cf4  (last->\cf9 next\cf4  != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
        last = last->\cf9 next\cf4 ;\
    \}\
    \cf10 // Append the data to that last node\cf4 \
    last->\cf9 next\cf4  = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (data);\
    \}\
\
\}\
\

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listAdd\cf4 (\cf8 Node\cf4 * where, 
\f1\b \cf2 int
\f2\b0 \cf4  data) \{\
    \cf10 // create a node for the data;\cf4 \
    \cf10 // Node* tmp = new Node(data);\cf4 \
\
    \cf10 // // Make our node point to the one after the "where" node\cf4 \
    \cf10 // tmp->next = where->next;\cf4 \
\
    \cf10 //Node* tmp = new Node(data, where->next);\cf4 \
\
    \cf10 // make where node point to the new one\cf4 \
    \cf10 //where->next = tmp;\cf4 \
\
    
\f1\b \cf2 if
\f2\b0 \cf4  (where != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    where->\cf9 next\cf4  = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (data, where->\cf9 next\cf4 );\
    \}\
    \
\}\
\

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listDisplayR\cf4 (\cf8 Node\cf4 * headPtr) \{\
    
\f1\b \cf2 if
\f2\b0 \cf4  (headPtr != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    \cf11 cout\cf4  << headPtr->\cf9 data\cf4  << \cf7 ' '\cf4 ;\
    \cf10 //    if (headPtr->next != nullptr) \{\cf4 \
    \cf9 listDisplayR\cf4 (headPtr->\cf9 next\cf4 );\
    \cf10 //    \}\cf4 \
    \}\
\}\
\
\cf10 //void listDisplay(Node* headPtr) const \{\cf4 \

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listDisplay\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * headPtr) \{\
    
\f1\b \cf2 while
\f2\b0 \cf4  (headPtr != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    \cf11 cout\cf4  << headPtr->\cf9 data\cf4  << \cf7 ' '\cf4 ;\
    headPtr = headPtr->\cf9 next\cf4 ;\
    \}\
    \cf11 cout\cf4  << \cf11 endl\cf4 ;\
\}\
\

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listDisplay2\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * headPtr) \{\
    
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * p = headPtr;\
    
\f1\b \cf2 while
\f2\b0 \cf4  (p != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    \cf11 cout\cf4  << p->\cf9 data\cf4  << \cf7 ' '\cf4 ;\
    p = p->\cf9 next\cf4 ;\
    \}\
    \cf11 cout\cf4  << \cf11 endl\cf4 ;\
\}\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 listLength\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * headPtr) \{\
    
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * p = headPtr;\
    
\f1\b \cf2 int
\f2\b0 \cf4  count = \cf7 0\cf4 ;\
    
\f1\b \cf2 while
\f2\b0 \cf4  (p != 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ) \{\
    ++count;\
    p = p->\cf9 next\cf4 ;\
    \}\
    
\f1\b \cf2 return
\f2\b0 \cf4  count;\
\}\
\

\f1\b \cf2 void
\f2\b0 \cf4  \cf6 listAddHead\cf4 (\cf8 Node\cf4 *& headPtr, 
\f1\b \cf2 int
\f2\b0 \cf4  data) \{\
    \cf10 // // create a node for the data\cf4 \
    \cf10 // Node* tmp = new Node(data);\cf4 \
\
    \cf10 // // made that node point to the old head node\cf4 \
    \cf10 // tmp->next = headPtr;\cf4 \
    \cf10 // Node* tmp = new Node(data, headPtr);\cf4 \
\
    \cf10 // // make the headPtr point to that node\cf4 \
    \cf10 // headPtr = tmp;\cf4 \
    headPtr = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (data, headPtr);\
\}\
\
\cf8 Node\cf4 * \cf6 listDup2\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf8 Node\cf4 * toDup) \{\
    
\f1\b \cf2 if
\f2\b0 \cf4  (!toDup) 
\f1\b \cf2 return
\f2\b0 \cf4  
\f1\b \cf2 nullptr
\f2\b0 \cf4 ;\
    \cf8 Node\cf4 * res = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (toDup->\cf9 data\cf4 );\
    res->\cf9 next\cf4  = \cf9 listDup2\cf4 (toDup->\cf9 next\cf4 );\
    
\f1\b \cf2 return
\f2\b0 \cf4  res;\
\}\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    \cf8 Node\cf4 * myList = 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ;\
    \cf9 listDisplay\cf4 (myList);\
\
\
    \cf9 listAddHead\cf4 (myList, \cf7 17\cf4 );\
    myList->\cf9 next\cf4  = 
\f1\b \cf2 new
\f2\b0 \cf4  \cf8 Node\cf4 (\cf7 28\cf4 );\
    \cf9 listDisplay\cf4 (myList);\
\
\
    \cf9 listAddHead\cf4 (myList, \cf7 6\cf4 );\
    \cf9 listDisplay\cf4 (myList);\
    \
    \cf9 listAddTail\cf4 (myList, \cf7 8\cf4 );\
    \cf9 listDisplay\cf4 (myList);\
    \
    \cf8 Node\cf4 * dup = \cf9 listDuplicate\cf4 (myList);\
    \cf9 listDisplay\cf4 (dup);\
    \
    \cf8 Node\cf4 * dup2 = \cf9 listDup2\cf4 (dup);\
    \cf9 listDisplay\cf4 (dup2);\
\}\
\
\
\cf10 more method hiding\cf4 \
\

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 A\cf4  \{\

\f1\b \cf2 public
\f2\b0 \cf4 :\
    
\f1\b \cf2 virtual
\f2\b0 \cf4  
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 foo\cf4 (
\f1\b \cf2 int
\f2\b0 \cf4 ) \{ \cf11 cout\cf4  << \cf12 "A"\cf4 ; \}\
\};\
\

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 B\cf4 : 
\f1\b \cf2 public
\f2\b0 \cf4  \cf8 A\cf4  \{\

\f1\b \cf2 public
\f2\b0 \cf4 :\
\cf10 //    using A::foo;\cf4 \
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 foo\cf4 (
\f1\b \cf2 const
\f2\b0 \cf4  \cf13 string\cf4 &) \{ \cf11 cout\cf4  << \cf12 "B"\cf4 ; \}\
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 bar\cf4 () \{ \cf8 A\cf4 ::\cf9 foo\cf4 (\cf7 2\cf4 ); \}\
\};\
\
SOMETHING ABOUT PTRS AND CONSTS\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    \cf8 B\cf4  b;\
    b.\cf8 A\cf4 ::\cf9 foo\cf4 (\cf7 2\cf4 );\
\}\
\

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 X\cf4  \{\
    \
    X* p;\

\f1\b \cf2 public
\f2\b0 \cf4 : \cf6 X\cf4 () \{ p = 
\f1\b \cf2 nullptr
\f2\b0 \cf4 ; \}\
    \
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 foo\cf4 () \{ p = p->p; \}\
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 bar\cf4 () 
\f1\b \cf2 const
\f2\b0 \cf4  \{ p->foo(); \}\
\};\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    X x;\
    x.foo();\
\}\
\
\cf10 //
\f1\b \cf14 MARK: ambiguity only when it is called upon. If no ambiguity then none.
\f2\b0 \cf4 \

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 String\cf4 \
\{\

\f1\b \cf2 public
\f2\b0 \cf4 :\
    \cf6 String\cf4 (
\f1\b \cf2 char
\f2\b0 \cf4  s) \{ \cf11 cout\cf4  << \cf7 2\cf4  << s << \cf11 endl\cf4 ; \}\
    String(
\f1\b \cf2 int
\f2\b0 \cf4  n) \{ \cf11 cout\cf4  << \cf7 1\cf4  << \cf11 endl\cf4 ; \}\
\};\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    \cf8 String\cf4  s1 = \cf7 123\cf4 ;\
    \cf8 String\cf4  s2 = \cf7 'r'\cf4 ;\
    \cf8 String\cf4  s4 = \cf7 3.14\cf4 ;\
\}\
\
\cf10 //
\f1\b \cf14 MARK: override and overload whenn protected
\f2\b0 \cf4 \
\

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 X\cf4  \{\

\f1\b \cf2 protected
\f2\b0 \cf4 :\
    
\f1\b \cf2 virtual
\f2\b0 \cf4  
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 y\cf4 () \{ \cf11 cout\cf4  << \cf7 2\cf4 ; \}\
    \

\f1\b \cf2 public
\f2\b0 \cf4 :\
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 y\cf4 (
\f1\b \cf2 int
\f2\b0 \cf4  ) \{ \cf11 cout\cf4  << \cf7 3\cf4 ; \}\
\};\
\

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 Y\cf4  : 
\f1\b \cf2 public
\f2\b0 \cf4  \cf8 X\cf4  \{\

\f1\b \cf2 public
\f2\b0 \cf4 :\
    
\f1\b \cf2 using
\f2\b0 \cf4  \cf8 X\cf4 ::y;\
    
\f1\b \cf2 void
\f2\b0 \cf4  \cf6 y\cf4 () \{ \cf11 cout\cf4  << \cf7 4\cf4 ; \}\
\};\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    \cf8 Y\cf4  y;\
    \cf8 Y\cf4 * x = &y;\
    x->\cf9 y\cf4 (\cf7 2\cf4 );\
\}\
\
\cf10 // 
\f1\b \cf14 MARK: not java where there is no spoon. There is an X always when it starts.
\f2\b0 \cf4 \

\f1\b \cf2 class
\f2\b0 \cf4  \cf5 X\cf4  \{\

\f1\b \cf2 public
\f2\b0 \cf4 :\
    \cf6 X\cf4 (
\f1\b \cf2 int
\f2\b0 \cf4 ) \{ \}\
\};\
\

\f1\b \cf2 int
\f2\b0 \cf4  \cf6 main\cf4 () \{\
    \cf8 X\cf4  x;\
\}\
\
\
	}